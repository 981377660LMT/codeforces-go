package leetcode

import (
	"encoding/json"
	"fmt"
	"github.com/levigross/grequests"
	"github.com/skratchdot/open-golang/open"
	"golang.org/x/net/html"
	"io/ioutil"
	"os"
	"strings"
	"testing"
)

// TODO: sleep when contest not begin.

func login(username, password string) (session *grequests.Session, err error) {
	const ua = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"
	session = grequests.NewSession(&grequests.RequestOptions{
		UserAgent:    ua,
		UseCookieJar: true,
	})

	// "touch" csrfToken
	csrfTokenURL := fmt.Sprintf("https://%s/graphql/", host)
	resp, err := session.Post(csrfTokenURL, &grequests.RequestOptions{
		JSON: map[string]string{"operationName": "globalData", "query": "query globalData {\n  feature {\n    questionTranslation\n    subscription\n    signUp\n    discuss\n    mockInterview\n    contest\n    store\n    book\n    chinaProblemDiscuss\n    socialProviders\n    studentFooter\n    cnJobs\n    __typename\n  }\n  userStatus {\n    isSignedIn\n    isAdmin\n    isStaff\n    isSuperuser\n    isTranslator\n    isPremium\n    isVerified\n    isPhoneVerified\n    isWechatVerified\n    checkedInToday\n    username\n    realName\n    userSlug\n    groups\n    jobsCompany {\n      nameSlug\n      logo\n      description\n      name\n      legalName\n      isVerified\n      permissions {\n        canInviteUsers\n        canInviteAllSite\n        leftInviteTimes\n        maxVisibleExploredUser\n        __typename\n      }\n      __typename\n    }\n    avatar\n    optedIn\n    requestRegion\n    region\n    activeSessionId\n    permissions\n    notificationStatus {\n      lastModified\n      numUnread\n      __typename\n    }\n    completedFeatureGuides\n    useTranslation\n    __typename\n  }\n  siteRegion\n  chinaHost\n  websocketUrl\n}\n"},
	})
	if err != nil {
		return
	}
	if !resp.Ok {
		return nil, fmt.Errorf("POST %s return code %d", csrfTokenURL, resp.StatusCode)
	}
	var csrfToken string
	for _, c := range resp.RawResponse.Cookies() {
		if c.Name == "csrftoken" {
			csrfToken = c.Value
			break
		}
	}
	if csrfToken == "" {
		return nil, fmt.Errorf("csrftoken not found")
	}

	// login
	loginURL := fmt.Sprintf("https://%s/accounts/login/", host)
	resp, err = session.Post(loginURL, &grequests.RequestOptions{
		Data: map[string]string{
			"csrfmiddlewaretoken": csrfToken,
			"login":               username,
			"password":            password,
			"next":                "/",
		},
		Headers: map[string]string{
			"origin":  "https://" + host,
			"referer": "https://" + host + "/",
		},
	})
	if err != nil {
		return
	}
	if !resp.Ok {
		return nil, fmt.Errorf("POST %s return code %d", loginURL, resp.StatusCode)
	}
	return
}

type problem struct {
	id            string
	urlZH         string
	urlEN         string
	defaultCode   string
	funcName      string
	isFuncProblem bool
	funcLos       []int
	sampleIns     [][]string
	sampleOuts    [][]string
}

func (p *problem) createDir() error {
	return os.MkdirAll(contestDir+p.id, os.ModePerm)
}

var _firstMainFileOpened bool

func (p *problem) writeMainFile() error {
	imports := ""
	if strings.Contains(p.defaultCode, "Definition for") {
		// add imports
		imports = `
import . "github.com/EndlessCheng/codeforces-go/leetcode/testutil"
`
	}
	p.defaultCode = strings.TrimSpace(p.defaultCode)
	fileContent := fmt.Sprintf(`package main
%s
%s
`, imports, p.defaultCode)

	filePath := contestDir + fmt.Sprintf("%[1]s/%[1]s.go", p.id)
	if !_firstMainFileOpened {
		_firstMainFileOpened = true
		defer open.Run(absPath(filePath))
	}
	return ioutil.WriteFile(filePath, []byte(fileContent), 0644)
}

func (p *problem) writeTestFile() error {
	var testStr string
	if !p.isFuncProblem {
		// 编写类和类方法
		sampleToStr := func(samples [][]string) (s string) {
			for i, text := range samples {
				if i > 0 {
					s += ", "
				}
				s += "`\n" + text[0] + "`"
			}
			return
		}
		sampleToOnlineStr := func(samples [][]string) (s string) {
			for _, text := range samples {
				s += text[0]
			}
			return
		}
		testStr = fmt.Sprintf(`// Code generated by generator_test.
package main

import (
	"github.com/EndlessCheng/codeforces-go/leetcode/testutil"
	"github.com/stretchr/testify/assert"
	"strings"
	"testing"
)

func Test(t *testing.T) {
	t.Log("Current test is [%s]")
	exampleIns := []string{%s}
	exampleOuts := []string{%s}
	// custom test cases or WA cases.
	//exampleIns = append(exampleIns, `+"``"+`)
	//exampleOuts = append(exampleOuts, `+"``"+`)
	if err := testutil.RunLeetCodeClassWithCase(t, Constructor, exampleIns, exampleOuts, 0); err != nil {
		t.Fatal(err)
	}
}

func TestOnline(t *testing.T) {
	t.Log("Current test is [%s]")
	// copy to the Custom Testcase
	const exampleIns = `+"`\n%s`"+`
	exampleOuts := `+"`\n%s`"+`
	// copy Your answer in the Run Code Result
	yourAnswers := `+"`\n\n`"+`
	assert.Equal(t, strings.TrimSpace(exampleOuts), strings.TrimSpace(yourAnswers))
}
`, p.id, sampleToStr(p.sampleIns), sampleToStr(p.sampleOuts), p.id, sampleToOnlineStr(p.sampleIns), sampleToOnlineStr(p.sampleOuts))
	} else {
		// 编写函数
		sampleToStr := func(samples [][]string) (s string) {
			for i, args := range samples {
				if i > 0 {
					s += ", "
				}
				s += "{"
				for j, arg := range args {
					if j > 0 {
						s += ", "
					}
					s += "`" + arg + "`"
				}
				s += "}"
			}
			return
		}
		testStr = fmt.Sprintf(`// Code generated by generator_test.
package main

import (
	"github.com/EndlessCheng/codeforces-go/leetcode/testutil"
	"testing"
)

func Test(t *testing.T) {
	t.Log("Current test is [%s]")
	exampleIns := [][]string{%s}
	exampleOuts := [][]string{%s}
	// custom test cases or WA cases.
	//exampleIns = append(exampleIns, []string{`+"``"+`})
	//exampleOuts = append(exampleOuts, []string{`+"``"+`})
	if err := testutil.RunLeetCodeFuncWithCase(t, %s, exampleIns, exampleOuts, 0); err != nil {
		t.Fatal(err)
	}
}
`, p.id, sampleToStr(p.sampleIns), sampleToStr(p.sampleOuts), p.funcName)
	}

	filePath := contestDir + fmt.Sprintf("%[1]s/%[1]s_test.go", p.id)
	return ioutil.WriteFile(filePath, []byte(testStr), 0644)
}

// 解析一个样例输入或输出
func (p *problem) parseSampleText(text string, parseArgs bool) []string {
	text = strings.TrimSpace(text)
	// 按 \n split 后 TrimSpace 再合并
	lines := strings.Split(text, "\n")
	text = ""
	for _, l := range lines {
		text += strings.TrimSpace(l)
		if !p.isFuncProblem {
			text += "\n"
		}
	}

	// 包含中文的话，说明原始数据有误，截断首个中文字符之后的字符
	if idx := findNonASCII(text); idx != -1 {
		fmt.Println("[warn] 数据有误，截断", text)
		text = text[:idx]
	}

	// 只有一个参数
	if !parseArgs || !strings.Contains(text, "=") {
		return []string{text}
	}

	// TODO: 处理参数含有 = 的情况
	splits := strings.Split(text, "=")
	sample := make([]string, 0, len(splits)-1)
	for _, s := range splits[1 : len(splits)-1] {
		end := strings.LastIndexByte(s, ',')
		sample = append(sample, strings.TrimSpace(s[:end]))
	}
	sample = append(sample, strings.TrimSpace(splits[len(splits)-1]))
	if !p.isFuncProblem {
		sample = []string{strings.Join(sample, "\n") + "\n"}
	}
	return sample
}

func (p *problem) parseHTML(session *grequests.Session) (err error) {
	defer func() {
		// visit htmlNode may cause panic
		if er := recover(); er != nil {
			err = fmt.Errorf("%v", er)
		}
	}()

	resp, err := session.Get(p.urlZH, nil)
	if err != nil {
		return
	}
	if !resp.Ok {
		return fmt.Errorf("GET %s return code %d", p.urlZH, resp.StatusCode)
	}

	rootNode, err := html.Parse(resp)
	if err != nil {
		return err
	}

	htmlNode := rootNode.FirstChild.NextSibling
	var bodyNode *html.Node
	for o := htmlNode.FirstChild; o != nil; o = o.NextSibling {
		if o.Type == html.ElementNode && o.Data == "body" {
			bodyNode = o
			break
		}
	}

	// parse defaultCode
	for o := bodyNode.FirstChild; o != nil; o = o.NextSibling {
		if o.Type == html.ElementNode && o.Data == "script" && o.FirstChild != nil {
			jsText := o.FirstChild.Data
			if start := strings.Index(jsText, "codeDefinition:"); start != -1 {
				end := strings.Index(jsText, "enableTestMode")
				jsonText := jsText[start+len("codeDefinition:") : end]
				jsonText = strings.TrimSpace(jsonText)
				jsonText = jsonText[:len(jsonText)-3] + "]" // remove , at end
				jsonText = strings.Replace(jsonText, `'`, `"`, -1)

				data := []struct {
					Value       string `json:"value"`
					DefaultCode string `json:"defaultCode"`
				}{}
				if err := json.Unmarshal([]byte(jsonText), &data); err != nil {
					return err
				}

				for _, template := range data {
					if template.Value == "golang" {
						p.defaultCode = strings.TrimSpace(template.DefaultCode)
						// 下面解析样例需要知道 p.isFuncProblem
						p.funcName, p.isFuncProblem, p.funcLos = parseCode(p.defaultCode)
						break
					}
				}
				// TODO: when defaultCode not found
				break
			}
		}
	}

	// parse sample inputs and sample outputs
	const (
		tokenInputZH  = "输入："
		tokenOutputZH = "输出："

		tokenInputEN  = "Input:"
		tokenOutputEN = "Output:"
	)

	isIn := true
	var f func(*html.Node)
	f = func(o *html.Node) {
		// 由于官方描述可能会打错字（比如“输入”写成“输出”），用 isIn 来交替 append 样例输入是最稳妥的
		if o.Type == html.TextNode && (strings.Contains(o.Data, tokenInputZH) || strings.Contains(o.Data, tokenOutputZH)) {
			if o.Parent.NextSibling == nil {
				return
			}
			if isIn {
				raw := o.Parent.NextSibling.Data
				sample := p.parseSampleText(raw, true)
				if sample == nil { // 官方描述打错。例如，“解释”写成了“输出”
					fmt.Fprintf(os.Stderr, "错误的输入数据：%s\n", raw)
					return
				}
				p.sampleIns = append(p.sampleIns, sample)
			} else {
				raw := o.Parent.NextSibling.Data
				sample := p.parseSampleText(raw, true)
				if sample == nil {
					fmt.Fprintf(os.Stderr, "错误的输出数据：%s\n", raw)
					return
				}
				p.sampleOuts = append(p.sampleOuts, sample)
			}
			isIn = !isIn
			return
		}
		for c := o.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(bodyNode)

	if len(p.sampleIns) != len(p.sampleOuts) {
		return fmt.Errorf("len(sampleIns) != len(sampleOuts) : %d != %d", len(p.sampleIns), len(p.sampleOuts))
	}
	if len(p.sampleIns) == 0 {
		return fmt.Errorf("解析失败，未找到样例输入输出！")
	}
	return nil
}

func TestGenLeetCodeTests(t *testing.T) {
	username := os.Getenv("LEETCODE_USERNAME")
	password := os.Getenv("LEETCODE_PASSWORD")
	session, err := login(username, password)
	if err != nil {
		t.Fatal(err)
	}
	fmt.Println(host, "登录成功")

	contestInfoAPI := fmt.Sprintf("https://%s/contest/api/info/%s%d/", host, contestPrefix, contestID)
	resp, err := session.Get(contestInfoAPI, nil)
	if err != nil {
		t.Fatal(err)
	}
	if !resp.Ok {
		t.Fatalf("GET %s return code %d", contestInfoAPI, resp.StatusCode)
	}
	d := struct {
		Questions []struct {
			TitleSlug string `json:"title_slug"`
		} `json:"questions"`
	}{}
	if err := resp.JSON(&d); err != nil {
		t.Fatal(err)
	}
	if len(d.Questions) == 0 {
		t.Fatalf("未找到比赛或比赛尚未开始: %s%d", contestPrefix, contestID)
	}
	fmt.Println("题目链接获取成功，开始解析")

	problems := make([]*problem, len(d.Questions))
	for i, q := range d.Questions {
		problems[i] = &problem{
			id:    string('a' + i),
			urlZH: fmt.Sprintf("https://%s/contest/%s%d/problems/%s/", hostZH, contestPrefix, contestID, q.TitleSlug),
			urlEN: fmt.Sprintf("https://%s/contest/%s%d/problems/%s/", hostEN, contestPrefix, contestID, q.TitleSlug),
		}
	}

	if openWebPageZH {
		for _, p := range problems {
			if err := open.Run(p.urlZH); err != nil {
				t.Error(err)
			}
		}
	}
	if openWebPageEN {
		for _, p := range problems {
			if err := open.Run(p.urlEN); err != nil {
				t.Error(err)
			}
		}
	}

	for _, p := range problems {
		//if p.id != "a" {
		//	continue
		//}
		fmt.Println(p.id, p.urlZH)
		if err := p.parseHTML(session); err != nil {
			t.Error(p.id, err)
		}

		p.defaultCode = modifyDefaultCode(p.defaultCode, p.funcLos, []modifyLineFunc{
			toGolangReceiverName,
			lowerArgsFirstChar,
			namedReturnFunc("ans"),
		}, "\t\n\treturn")

		if err := p.createDir(); err != nil {
			t.Fatal(err) // IO
		}
		if err := p.writeMainFile(); err != nil {
			t.Fatal(err) // IO
		}
		if err := p.writeTestFile(); err != nil {
			t.Fatal(err) // IO
		}
	}
}
