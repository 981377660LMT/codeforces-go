package leetcode

import (
	"encoding/json"
	"fmt"
	"github.com/levigross/grequests"
	"github.com/skratchdot/open-golang/open"
	"golang.org/x/net/html"
	"io/ioutil"
	"os"
	"strings"
	"testing"
)

// TODO: sleep when contest not begin.
const contestID = 175

const (
	hostZH = "leetcode-cn.com"
	hostEN = "leetcode.com"
	host   = hostZH

	contestPrefixWeekly   = "weekly-contest-"
	contestPrefixBiweekly = "biweekly-contest-"
	contestPrefix         = contestPrefixWeekly

	openZH = true
	openEN = true
)

var (
	apiContestInfo = fmt.Sprintf("https://%s/contest/api/info/%s%d/", host, contestPrefix, contestID)
)

func newSession(username, password string) (session *grequests.Session, err error) {
	const ua = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"
	session = grequests.NewSession(&grequests.RequestOptions{
		UserAgent:    ua,
		UseCookieJar: true,
	})

	// TODO: leetCodeEN
	csrfTokenUrl := fmt.Sprintf("https://%s/graphql/", host)
	resp, err := session.Post(csrfTokenUrl, &grequests.RequestOptions{
		JSON: map[string]string{"operationName": "globalData", "query": "query globalData {\n  feature {\n    questionTranslation\n    subscription\n    signUp\n    discuss\n    mockInterview\n    contest\n    store\n    book\n    chinaProblemDiscuss\n    socialProviders\n    studentFooter\n    cnJobs\n    __typename\n  }\n  userStatus {\n    isSignedIn\n    isAdmin\n    isStaff\n    isSuperuser\n    isTranslator\n    isPremium\n    isVerified\n    isPhoneVerified\n    isWechatVerified\n    checkedInToday\n    username\n    realName\n    userSlug\n    groups\n    jobsCompany {\n      nameSlug\n      logo\n      description\n      name\n      legalName\n      isVerified\n      permissions {\n        canInviteUsers\n        canInviteAllSite\n        leftInviteTimes\n        maxVisibleExploredUser\n        __typename\n      }\n      __typename\n    }\n    avatar\n    optedIn\n    requestRegion\n    region\n    activeSessionId\n    permissions\n    notificationStatus {\n      lastModified\n      numUnread\n      __typename\n    }\n    completedFeatureGuides\n    useTranslation\n    __typename\n  }\n  siteRegion\n  chinaHost\n  websocketUrl\n}\n"},
	})
	if err != nil {
		return
	}
	if !resp.Ok {
		return nil, fmt.Errorf("POST %s return code %d", csrfTokenUrl, resp.StatusCode)
	}
	var csrfToken string
	for _, c := range resp.RawResponse.Cookies() {
		if c.Name == "csrftoken" {
			csrfToken = c.Value
			break
		}
	}
	if csrfToken == "" {
		panic("csrftoken not found")
	}

	loginUrl := fmt.Sprintf("https://%s/accounts/login/", host)
	resp, err = session.Post(loginUrl, &grequests.RequestOptions{
		Data: map[string]string{
			"csrfmiddlewaretoken": csrfToken,
			"login":               username,
			"password":            password,
			"next":                "/",
		},
		Headers: map[string]string{
			"origin":  "https://" + host,
			"referer": "https://" + host + "/",
		},
	})
	if err != nil {
		panic(err)
	}
	if !resp.Ok {
		return nil, fmt.Errorf("POST %s return code %d", loginUrl, resp.StatusCode)
	}

	fmt.Println("登录成功", host)
	return
}

var contestDir = fmt.Sprintf("../../../leetcode/%d/", contestID)

func createDir(problemID string) error {
	dirPath := contestDir + problemID
	return os.MkdirAll(dirPath, os.ModePerm)
}

var isOpenedMainFile bool

func writeMainFile(problemID, defaultCode string) error {
	defaultCode = strings.TrimSpace(defaultCode)
	mainStr := fmt.Sprintf(`package main

%s
`, defaultCode)
	filePath := contestDir + fmt.Sprintf("%[1]s/%[1]s.go", problemID)
	if !isOpenedMainFile {
		defer open.Run(absPath(filePath))
		isOpenedMainFile = true
	}
	return ioutil.WriteFile(filePath, []byte(mainStr), 0644)
}

func writeTestFile(problemID, funcName string, sampleIns, sampleOuts [][]string) error {
	funcName = strings.TrimSpace(funcName)

	var testStr string
	if funcName == "" {
		// 编写类
		sampleToStr := func(samples [][]string) (s string) {
			for _, text := range samples {
				s += text[0]
			}
			return
		}
		testStr = fmt.Sprintf(`package main

import (
	"github.com/stretchr/testify/assert"
	"strings"
	"testing"
)

func Test(t *testing.T) {
	t.Log("Current test is [%s]")
	// copy to the Custom Testcase
	const exampleIns = `+"`\n%s`"+`
	exampleOuts := `+"`\n%s`"+`
	// copy Your answer in the Run Code Result
	yourAnswers := `+"`\n\n`"+`
	assert.Equal(t, strings.TrimSpace(exampleOuts), strings.TrimSpace(yourAnswers))
}
`, problemID, sampleToStr(sampleIns), sampleToStr(sampleOuts))
	} else {
		// 编写函数
		sampleToStr := func(samples [][]string) (s string) {
			for i, args := range samples {
				if i > 0 {
					s += ", "
				}
				s += "{"
				for j, arg := range args {
					if j > 0 {
						s += ", "
					}
					s += "`" + arg + "`"
				}
				s += "}"
			}
			return
		}
		testStr = fmt.Sprintf(`// Code generated by generator_test.
package main

import (
	"github.com/EndlessCheng/codeforces-go/leetcode/testutil"
	"testing"
)

func Test(t *testing.T) {
	t.Log("Current test is [%s]")
	exampleIns := [][]string{%s}
	exampleOuts := [][]string{%s}
	// custom test cases or WA cases.
	//exampleIns = append(exampleIns, []string{`+"``"+`})
	//exampleOuts = append(exampleOuts, []string{`+"``"+`})
	if err := testutil.RunLeetCodeFuncWithCase(t, %s, exampleIns, exampleOuts, 0); err != nil {
		t.Fatal(err)
	}
}
`, problemID, sampleToStr(sampleIns), sampleToStr(sampleOuts), funcName)
	}

	filePath := contestDir + fmt.Sprintf("%[1]s/%[1]s_test.go", problemID)
	return ioutil.WriteFile(filePath, []byte(testStr), 0644)
}

func parseHTML(session *grequests.Session, fileName string, htmlURL string) (retErr error) {
	defer func() {
		if er := recover(); er != nil {
			retErr = fmt.Errorf("%v", er)
		}
	}()

	resp, err := session.Get(htmlURL, nil)
	if err != nil {
		return err
	}
	if !resp.Ok {
		return fmt.Errorf("GET %s return code %d", htmlURL, resp.StatusCode)
	}

	root, err := html.Parse(resp)
	if err != nil {
		return err
	}

	htmlNode := root.FirstChild.NextSibling
	var bodyNode *html.Node
	for o := htmlNode.FirstChild; o != nil; o = o.NextSibling {
		if o.Type == html.ElementNode && o.Data == "body" {
			bodyNode = o
			break
		}
	}

	// 解析模板（codeDefinition）
	var funcName string
	var isFuncProblem bool // 编写函数还是类
	for o := bodyNode.FirstChild; o != nil; o = o.NextSibling {
		if o.Type == html.ElementNode && o.Data == "script" && o.FirstChild != nil {
			jsText := o.FirstChild.Data
			if start := strings.Index(jsText, "codeDefinition:"); start != -1 {
				end := strings.Index(jsText, "enableTestMode")
				jsonText := jsText[start+len("codeDefinition:") : end]
				jsonText = strings.TrimSpace(jsonText)
				jsonText = jsonText[:len(jsonText)-3] + "]" // remove , at end
				jsonText = strings.Replace(jsonText, `'`, `"`, -1)

				d := []struct {
					Value       string `json:"value"`
					DefaultCode string `json:"defaultCode"`
				}{}
				if err := json.Unmarshal([]byte(jsonText), &d); err != nil {
					return err
				}

				for _, e := range d {
					if e.Value == "golang" {
						// 模板解析完成，写入 <problemID>.go
						code := e.DefaultCode
						code = strings.TrimSpace(code)
						funcName, isFuncProblem = parseFuncName(code)
						if isFuncProblem {
							code = lowerFirstChar(code)
							code = namedReturn(code, "ans")
							code = customContent(code, "\t\n\treturn")
						}
						if err := writeMainFile(fileName, code); err != nil {
							return err
						}
						break
					}
				}
				break
			}
		}
	}

	// 解析样例输入输出
	const (
		tokenInputZH  = "输入："
		tokenOutputZH = "输出："

		tokenInputEN  = "Input:"
		tokenOutputEN = "Output:"
	)

	var sampleIns, sampleOuts [][]string
	parseSampleText := func(text string, parseArgs bool) (sample []string) {
		text = strings.TrimSpace(text)
		// 按 \n split 后 TrimSpace 再合并
		lines := strings.Split(text, "\n")
		text = ""
		for _, l := range lines {
			text += strings.TrimSpace(l)
			if !isFuncProblem {
				text += "\n"
			}
		}

		if idx := findASCII(text); idx != -1 {
			// 包含中文的话，说明原始数据有误，截断首个中文字符之后的字符
			fmt.Println("[warn] 数据有误，截断", text)
			text = text[:idx]
		}

		if !parseArgs || !strings.Contains(text, "=") {
			// 只有一个参数
			return []string{text}
		}

		splits := strings.Split(text, "=")
		sample = make([]string, 0, len(splits)-1)
		for _, s := range splits[1 : len(splits)-1] {
			end := strings.LastIndexByte(s, ',')
			sample = append(sample, strings.TrimSpace(s[:end]))
		}
		sample = append(sample, strings.TrimSpace(splits[len(splits)-1]))

		if !isFuncProblem {
			sample = []string{strings.Join(sample, "\n") + "\n"}
		}

		return
	}
	isIn := true
	var f func(*html.Node)
	f = func(o *html.Node) {
		// 由于官方描述可能会打错字（比如“输入”写成“输出”），用 isIn 来交替 append 样例输入是最稳妥的
		if o.Type == html.TextNode && (strings.Contains(o.Data, tokenInputZH) || strings.Contains(o.Data, tokenOutputZH)) {
			if o.Parent.NextSibling == nil {
				return
			}
			if isIn {
				raw := o.Parent.NextSibling.Data
				sample := parseSampleText(raw, true)
				if sample == nil { // 官方描述打错。例如，“解释”写成了“输出”
					fmt.Fprintf(os.Stderr, "错误的输入数据：%s\n", raw)
					return
				}
				sampleIns = append(sampleIns, sample)
			} else {
				raw := o.Parent.NextSibling.Data
				sample := parseSampleText(raw, true)
				if sample == nil {
					fmt.Fprintf(os.Stderr, "错误的输出数据：%s\n", raw)
					return
				}
				sampleOuts = append(sampleOuts, sample)
			}
			isIn = !isIn
			return
		}
		for c := o.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(bodyNode)

	if len(sampleIns) != len(sampleOuts) {
		return fmt.Errorf("len(sampleIns) != len(sampleOuts) : %d != %d", len(sampleIns), len(sampleOuts))
	}

	if len(sampleIns) == 0 {
		return fmt.Errorf("解析失败，未找到样例输入输出！")
	}

	// 样例解析完成，写入 <problemID>_test.go
	if err := writeTestFile(fileName, funcName, sampleIns, sampleOuts); err != nil {
		return err
	}

	return nil
}

func TestGenLeetCodeTests(t *testing.T) {
	username := os.Getenv("LEETCODE_USERNAME")
	password := os.Getenv("LEETCODE_PASSWORD")
	session, err := newSession(username, password)
	if err != nil {
		t.Fatal(err)
	}

	resp, err := session.Get(apiContestInfo, nil)
	if err != nil {
		t.Fatal(err)
	}
	if !resp.Ok {
		t.Fatalf("GET %s return code %d", apiContestInfo, resp.StatusCode)
	}
	d := struct {
		Questions []struct {
			TitleSlug string `json:"title_slug"`
		} `json:"questions"`
	}{}
	if err := resp.JSON(&d); err != nil {
		t.Fatal(err)
	}
	if len(d.Questions) == 0 {
		t.Fatal("未找到比赛或比赛尚未开始")
	}

	fmt.Println("题目链接获取成功，开始解析")
	problemURLs := make([]string, len(d.Questions))
	for i, q := range d.Questions {
		problemURLs[i] = fmt.Sprintf("https://%s/contest/%s%d/problems/%s/", host, contestPrefix, contestID, q.TitleSlug)
	}

	// open all urls in browser
	if openZH {
		for _, u := range problemURLs {
			if err := open.Run(u); err != nil {
				t.Error(err)
			}
		}
	}
	if openEN {
		for _, q := range d.Questions {
			u := fmt.Sprintf("https://%s/contest/%s%d/problems/%s/", hostEN, contestPrefix, contestID, q.TitleSlug)
			if err := open.Run(u); err != nil {
				t.Error(err)
			}
		}
	}

	for i, pUrl := range problemURLs {
		problemID := string('a' + i)
		//if problemID != "f" {
		//	continue
		//}
		fmt.Println(problemID, pUrl)
		if err := createDir(problemID); err != nil {
			t.Fatal(err)
		}
		if err := parseHTML(session, problemID, pUrl); err != nil {
			t.Error(err, problemID, pUrl)
			continue
		}
	}
}
