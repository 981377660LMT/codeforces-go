官解写的是递归套递归的写法，这里提供只有一个递归函数的写法。

仍然是两个参数，链表节点 $s$ 和二叉树节点 $t$。分类讨论：

1. 如果 $s$ 是空的，说明整个链表匹配完毕，返回 $\texttt{true}$。
2. 否则需要继续匹配。如果 $t$ 是空的，说明匹配失败，返回 $\texttt{false}$。
3. 如果 $s$ 的节点值等于 $t$ 的节点值，那么继续匹配，递归 $s$ 的下一个节点和 $t$ 的左右儿子。
4. 如果 $s$ 的节点值不等于 $t$ 的节点值，那么从 $\textit{head}$ 开始重新匹配，递归 $\textit{head}$ 和 $t$ 的左右儿子。注意只在 $s$ 等于 $\textit{head}$ 的时候才去递归，如果不加这句话，可能情况 3 中链表匹配到一半，匹配失败，那么前面匹配成功的每个节点都会进入情况 4，这样会发生大量重复调用，时间复杂度将会是指数级别的。为了保证没有重复调用，我们规定只有当 $s$ 是链表头的时候，才进入情况 4 的递归。

```py [sol-Python3]
class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        def dfs(s: Optional[ListNode], t: Optional[TreeNode]) -> bool:
            if s is None:  # 整个链表匹配完毕
                return True
            # 否则需要继续匹配
            if t is None:  # 无法继续匹配
                return False
            # 节点值相同则继续匹配，否则从 head 开始重新匹配
            return s.val == t.val and (dfs(s.next, t.left) or dfs(s.next, t.right)) or \
                   s is head and (dfs(head, t.left) or dfs(head, t.right))
        return dfs(head, root)
```

```java [sol-Java]
class Solution {
    private ListNode head;

    public boolean isSubPath(ListNode head, TreeNode root) {
        this.head = head;
        return dfs(head, root);
    }

    private boolean dfs(ListNode s, TreeNode t) {
        if (s == null) { // 整个链表匹配完毕
            return true;
        }
        // 否则需要继续匹配
        if (t == null) { // 无法继续匹配
            return false;
        }
        // 节点值相同则继续匹配，否则从 head 开始重新匹配
        return s.val == t.val && (dfs(s.next, t.left) || dfs(s.next, t.right)) ||
               s == head && (dfs(head, t.left) || dfs(head, t.right));
    }
}
```

```cpp [sol-C++]
class Solution {
public:
    bool isSubPath(ListNode* head, TreeNode* root) {
        auto dfs = [&](this auto&& dfs, ListNode* s, TreeNode* t) -> bool {
            if (s == nullptr) { // 整个链表匹配完毕
                return true;
            }
            // 否则需要继续匹配
            if (t == nullptr) { // 无法继续匹配
                return false;
            }
            // 节点值相同则继续匹配，否则从 head 开始重新匹配
            return s->val == t->val && (dfs(s->next, t->left) || dfs(s->next, t->right)) ||
                   s == head && (dfs(head, t->left) || dfs(head, t->right));
        };
        return dfs(head, root);
    }
};
```

```go [sol-Go]
func isSubPath(head *ListNode, root *TreeNode) bool {
    var dfs func(*ListNode, *TreeNode) bool
    dfs = func(s *ListNode, t *TreeNode) bool {
        if s == nil { // 整个链表匹配完毕
            return true
        }
        // 否则需要继续匹配
        if t == nil { // 无法继续匹配
            return false
        }
        // 节点值相同则继续匹配，否则从 head 开始重新匹配
        return s.Val == t.Val && (dfs(s.Next, t.Left) || dfs(s.Next, t.Right)) ||
               s == head && (dfs(head, t.Left) || dfs(head, t.Right))
    }
    return dfs(head, root)
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(nm)$，其中 $n$ 是链表的节点个数，$m$ 是二叉树的节点个数。
- 空间复杂度：$\mathcal{O}(m)$。最坏情况下，二叉树是一条链，因此递归需要 $\mathcal{O}(m)$ 的栈空间。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/最短路/最小生成树/二分图/基环树/欧拉路径）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/状态机/划分/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)
11. 【本题相关】[链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）](https://leetcode.cn/circle/discuss/K0n2gO/)
12. [字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）](https://leetcode.cn/circle/discuss/SJFwQI/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
