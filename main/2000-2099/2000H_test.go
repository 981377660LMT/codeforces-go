// Generated by copypasta/template/generator_test.go
package main

import (
	. "fmt"
	"github.com/EndlessCheng/codeforces-go/main/testutil"
	"io"
	"maps"
	"slices"
	"strings"
	"testing"
)

// https://codeforces.com/problemset/problem/2000/H
// https://codeforces.com/problemset/status/2000/problem/H?friends=on
var testCases2000H = [][2]string{
	{
		`3
5
1 2 5 905 2000000
15
- 2
? 2
? 1
- 1
? 1
+ 4
+ 2
? 2
+ 6
- 4
+ 7
? 2
? 3
? 4
? 2000000
5
3 4 5 6 8
9
? 5
- 5
? 5
+ 1
? 2
- 6
- 8
+ 6
? 5
5
6 7 8 9 10
10
? 5
- 6
? 4
- 10
+ 5
- 8
+ 3
+ 2
- 3
+ 10`,
		`2 2 1 6 3 8 8 2000001 
9 9 9 7 
1 1`,
	},
	{
		`1
2
6 11
2
? 3
? 6`,
		`1 12`,
	},
}

func Test_cf2000H(t *testing.T) {
	testutil.AssertEqualStringCase(t, testCases2000H, 0, cf2000H)
}

func TestCompare_cf2000H(_t *testing.T) {
	//return
	testutil.DebugTLE = 0
	rg := testutil.NewRandGenerator()
	inputGenerator := func() string {
		//return ``
		rg.Clear()
		rg.One()
		n := rg.Int(1, 5)
		rg.NewLine()
		const MX = 15
		a := rg.IntSliceOrdered(n, 1, MX, true, true)
		has := map[int]bool{}
		for _, v := range a {
			has[v] = true
		}
		m := rg.Int(1, 5)
		rg.NewLine()
		for range m {
			var op int
			for {
				op = rg.IntOnly(0, 2)
				if op != 1 || len(has) > 0 {
					break
				}
			}
			if op == 0 {
				rg.Bytes("+ ")
				b := []int{}
				for i := 1; i <= MX; i++ {
					if !has[i] {
						b = append(b, i)
					}
				}
				k := b[rg.IntOnly(0, len(b)-1)]
				rg.Int(k, k)
				has[k] = true
			} else if op == 1 {
				rg.Bytes("- ")
				b := slices.Collect(maps.Keys(has))
				k := b[rg.IntOnly(0, len(b)-1)]
				rg.Int(k, k)
				delete(has, k)
			} else {
				rg.Bytes("? ")
				rg.Int(1, MX)
			}
			rg.NewLine()
		}
		return rg.String()
	}

	// 暴力算法
	runBF := func(in io.Reader, out io.Writer) {
		solve := func(Case int) {
			var n, m, v int
			var op string
			Fscan(in, &n)
			has := map[int]bool{}
			for range n {
				Fscan(in, &v)
				has[v] = true
			}
			Fscan(in, &m)
			for range m {
				Fscan(in, &op, &v)
				if op == "+" {
					has[v] = true
				} else if op == "-" {
					delete(has, v)
				} else {
				o:
					for i := 1; i <= 20; i++ {
						for j := i; j < i+v; j++ {
							if has[j] {
								continue o
							}
						}
						Fprint(out, i, " ")
						break
					}
				}
			}
			Fprintln(out)
		}

		T := 1
		Fscan(in, &T)
		for Case := 1; Case <= T; Case++ {
			solve(Case)
		}

		_leftData, _ := io.ReadAll(in)
		if _s := strings.TrimSpace(string(_leftData)); _s != "" {
			panic("有未读入的数据：\n" + _s)
		}
	}

	//testutil.AssertEqualStringCase(_t, testCases2000H, 0, runBF)
	//return

	testutil.AssertEqualRunResultsInf(_t, inputGenerator, runBF, cf2000H)
}
