删边不好做，我们可以倒着处理询问，这样删边变成加边，可以用并查集解决。
注意没有被删除的边，要在倒序处理之前就用并查集合并。

但是，询问 1 会修改点权，必须正着做，没法倒着做。
如果能把询问 1 变成区间查询，就可以用线段树解决。

我们知道，子树 DFS 序（根节点的 in out 时间戳）可以对应一个连续区间。
那么在并查集 merge 的同时建树。比如 merge(1,2)，就把 find(1) 和 find(2) 之间连边，比如 find(1) 是 find(2) 的父节点。
此外，倒序遍历时，记录询问 1 对应的 find(v)。
那么用 find(v) 子树对应的区间去处理询问 1，是不是就行了呢？

这样做是不对的，find(1) 和 find(2) 之间连边，谁是父亲，谁是儿子？
如果 find(1) 是父亲，那么正序处理询问，把 1-2 的边删除后，子树 find(1) 仍然会包含 find(2)。

我们可以添加一个虚拟节点 u，把 find(1) 和 find(2) 都作为 u 的儿子，删边前回答的是子树 u，删边后回答的就是子树 find(1) 或者 find(2) 了。
按照该规则，在倒序遍历询问，并查集的 merge 中添加一个建树的逻辑。
倒序遍历结束后，从根节点，也就是 find(i) = i 的节点开始 DFS，算出每个节点的 in out 时间戳。
然后正序遍历，利用 in out 时间戳在线段树上处理。注意在倒序遍历时我们要计算出询问 1 的节点的 find(v)，这样才能查询子树的 in out 时间戳。

另外本题输入量很大，最好加上快读。
