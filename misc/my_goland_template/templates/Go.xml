<templateSet group="Go">
  <template name="for" value="for $VAR0$ := $INIT$; $VAR0$ &lt; $VAR1$; $VAR0$++ {&#10; $END$&#10;}" description="For loop" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;i&quot;" alwaysStopAt="true" />
    <variable name="INIT" expression="" defaultValue="&quot;0&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context />
  </template>
  <template name="rfor" value="for $VAR0$ := $VAR1$ - 1; $VAR0$ &gt;= $FINAL$; $VAR0$-- {&#10; $END$&#10;}" description="Reversed for loop" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;i&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <variable name="FINAL" expression="" defaultValue="&quot;0&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fsf" value="Fscanf(in, &quot;$FORMAT$&quot;, &amp;$VAR0$)" description="Fscanf(in, &quot;$FORMAT$&quot;, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="FORMAT" expression="" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fp" value="Fprintln(out, $VAR0$)" description="Fprintln(out, $VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs" value="Fscan(in, &amp;$VAR0$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fa" value="$VAR0$ := make([]$TYPE$, $VAR1$)&#10;for i := range $VAR0$ {&#10; Fscan(in, &amp;$VAR0$[i])&#10;}" description="for array read (read slice)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;a&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="tp" value="type pair struct { $VAR0$ }" description="type pair struct { $VAR0$ }" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;x, y int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="varf" value="var $VAR0$ func($VAR1$) $VAR2$&#10;$VAR0$ = func($VAR1$) $VAR2$ {&#10;&#9;$END$&#10;}&#10;$VAR0$($VAR3$)" description="Define a Recursion Function" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;f&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;v int&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="VAR3" expression="" defaultValue="&quot;0&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="vf" value="var $VAR0$ func($VAR1$) $VAR2$&#10;$VAR0$ = func($VAR1$) $VAR2$ {&#10;&#9;$END$&#10;}&#10;$VAR0$($VAR3$)" description="Define a Recursion Function" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;f&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;v int&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="VAR3" expression="" defaultValue="&quot;0&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="pair" value="type pair struct { $VAR0$ }" description="type pair struct { $VAR0$ }" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;x, y int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="mod" value="const mod $TYPE$ = 1e9 + 7" description="const mod int = 1e9 + 7" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="min" value="min := func(a, b $TYPE$) $TYPE$ {&#10;&#9;if a &lt; b {&#10;&#9;&#9;return a&#10;&#9;}&#10;&#9;return b&#10;}" description="min := func(a, b int) int" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="max" value="max := func(a, b $TYPE$) $TYPE$ {&#10;&#9;if a &gt; b {&#10;&#9;&#9;return a&#10;&#9;}&#10;&#9;return b&#10;}" description="max := func(a, b int) int" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="case" value="solve := func() (ans $TYPE$) {&#10;&#9;var n int&#10;&#9;Fscan(in, &amp;n)&#10;&#9;$END$&#10;&#9;&#10;&#9;return&#10;}&#10;&#10;var t int&#10;Fscan(in, &amp;t)&#10;for _case := 1; _case &lt;= t; _case++ {&#10;&#9;Fprintln(out, solve())&#10;}" description="multi test cases" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="ti" value="ternaryI := func(cond bool, r1, r2 int) int {&#10;&#9;if cond {&#10;&#9;&#9;return r1&#10;&#9;}&#10;&#9;return r2&#10;}" description="cond ? int : int" toReformat="true" toShortenFQNames="true" deactivated="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="ts" value="ternaryS := func(cond bool, r1, r2 string) string {&#10;&#9;if cond {&#10;&#9;&#9;return r1&#10;&#9;}&#10;&#9;return r2&#10;}" description="cond ? string : string" toReformat="true" toShortenFQNames="true" deactivated="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="yn" value="map[bool]string{true: &quot;YES&quot;, false: &quot;NO&quot;} [$VAR0$]" description="map[bool]string{true: &quot;YES&quot;, false: &quot;NO&quot;} [$VAR0$]" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;solve()&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="printf" value="fmt.Printf(&quot;$END$&quot;,$VAR$)" description="printf" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="VAR" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context />
  </template>
  <template name="err" value="if $ERR$ != nil {&#10; $END$&#10;}" description="If error" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="ERR" expression="errorVariable()" defaultValue="&quot;err&quot;" alwaysStopAt="true" />
    <context />
  </template>
  <template name="abs" value="abs := func(x int) int {&#10;&#9;if x &lt; 0 {&#10;&#9;&#9;return -x&#10;&#9;}&#10;&#9;return x&#10;}" description="abs := func(x int) int" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="vs" value="var $VAR0$ $VAR1$&#10;Fscan(in, &amp;$VAR0$)" description="var name &amp; Fscan" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="gcd" value="calcGCD := func(a, b $TYPE$) $TYPE$ {&#10;&#9;for a != 0 {&#10;&#9;&#9;a, b = b%a, a&#10;&#9;}&#10;&#9;return b&#10;}" description="calcGCD := func(a, b int) int" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="mii" value="map[int]int{}" description="map[int]int{}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO" value="true" />
      <option name="GO_BLOCK" value="false" />
      <option name="GO_FILE" value="false" />
      <option name="GO_STATEMENT" value="false" />
      <option name="GO_TAG_LITERAL" value="false" />
      <option name="GO_TYPE" value="false" />
    </context>
  </template>
  <template name="mis" value="map[int]string{}" description="map[int]string{}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO" value="true" />
      <option name="GO_BLOCK" value="false" />
      <option name="GO_FILE" value="false" />
      <option name="GO_STATEMENT" value="false" />
      <option name="GO_TAG_LITERAL" value="false" />
      <option name="GO_TYPE" value="false" />
    </context>
  </template>
  <template name="msi" value="map[string]int{}" description="map[string]int{}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO" value="true" />
      <option name="GO_BLOCK" value="false" />
      <option name="GO_FILE" value="false" />
      <option name="GO_STATEMENT" value="false" />
      <option name="GO_TAG_LITERAL" value="false" />
      <option name="GO_TYPE" value="false" />
    </context>
  </template>
  <template name="mss" value="map[string]string{}" description="map[string]string{}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO" value="true" />
      <option name="GO_BLOCK" value="false" />
      <option name="GO_FILE" value="false" />
      <option name="GO_STATEMENT" value="false" />
      <option name="GO_TAG_LITERAL" value="false" />
      <option name="GO_TYPE" value="false" />
    </context>
  </template>
  <template name="check" value="$VAR0$ &gt;= 0 &amp;&amp; $VAR0$ &lt; $VAR1$ &amp;&amp; $VAR2$ &gt;= 0 &amp;&amp; $VAR2$ &lt; $VAR3$" description="$VAR0$ &gt;= 0 &amp;&amp; $VAR0$ &lt; $VAR1$ &amp;&amp; $VAR2$ &gt;= 0 &amp;&amp; $VAR2$ &lt; $VAR3$" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;x&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="complete()" defaultValue="&quot;y&quot;" alwaysStopAt="true" />
    <variable name="VAR3" expression="complete()" defaultValue="&quot;m&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="nm" value="n, m := len($VAR0$), len($VAR0$[0])" description="n, m := len(mat), len(mat[0])" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;mat&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="dir4" value="dir4 := [...][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}" description="dir4 := [...][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="imp" value="import (&#10; &quot;$END$&quot;&#10;)&#10;" description="Import declaration" toReformat="true" toShortenFQNames="true" deactivated="true">
    <context />
  </template>
  <template name="p" value="package $NAME$" description="Package declaration" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="NAME" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context />
  </template>
  <template name="iota" value="const $NAME$ $TYPE$ = iota" description="Iota constant declaration" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="NAME" expression="" defaultValue="&quot;name&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context />
  </template>
  <template name="map" value="map[$KEY_TYPE$]$VALUE_TYPE$" description="Map type" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="KEY_TYPE" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <variable name="VALUE_TYPE" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context />
  </template>
  <template name=":" value="$NAME$ := $VALUE$" description="Variable declaration :=" toReformat="true" toShortenFQNames="true" deactivated="true">
    <variable name="NAME" expression="" defaultValue="&quot;name&quot;" alwaysStopAt="true" />
    <variable name="VALUE" expression="complete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="GO" value="true" />
    </context>
  </template>
  <template name="multiset" value="type node struct {&#10;&#9;lr       [2]*node&#10;&#9;priority uint&#10;&#9;key      $VAR0$&#10;&#9;dupCnt   int&#10;&#9;sz       int&#10;}&#10;&#10;func (o *node) size() int {&#10;&#9;if o != nil {&#10;&#9;&#9;return o.sz&#10;&#9;}&#10;&#9;return 0&#10;}&#10;&#10;func (o *node) pushUp() { o.sz = o.dupCnt + o.lr[0].size() + o.lr[1].size() }&#10;&#10;func (o *node) rotate(d int8) *node {&#10;&#9;x := o.lr[d^1]&#10;&#9;o.lr[d^1] = x.lr[d]&#10;&#9;x.lr[d] = o&#10;&#9;o.pushUp()&#10;&#9;x.pushUp()&#10;&#9;return x&#10;}&#10;&#10;type treap struct {&#10;&#9;rd   uint&#10;&#9;root *node&#10;}&#10;&#10;func (t *treap) fastRand() uint {&#10;&#9;t.rd ^= t.rd &lt;&lt; 13&#10;&#9;t.rd ^= t.rd &gt;&gt; 17&#10;&#9;t.rd ^= t.rd &lt;&lt; 5&#10;&#9;return t.rd&#10;}&#10;&#10;func (t *treap) less(a, b $VAR0$) int8 {&#10;&#9;switch {&#10;&#9;case a &lt; b:&#10;&#9;&#9;return 0&#10;&#9;case a &gt; b:&#10;&#9;&#9;return 1&#10;&#9;default:&#10;&#9;&#9;return -1&#10;&#9;}&#10;}&#10;&#10;func (t *treap) _put(o *node, key $VAR0$) *node {&#10;&#9;if o == nil {&#10;&#9;&#9;return &amp;node{priority: t.fastRand(), key: key, dupCnt: 1, sz: 1}&#10;&#9;}&#10;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;o.lr[d] = t._put(o.lr[d], key)&#10;&#9;&#9;if o.lr[d].priority &gt; o.priority {&#10;&#9;&#9;&#9;o = o.rotate(d ^ 1)&#10;&#9;&#9;}&#10;&#9;} else {&#10;&#9;&#9;o.dupCnt++&#10;&#9;}&#10;&#9;o.pushUp()&#10;&#9;return o&#10;}&#10;&#10;func (t *treap) put(key $VAR0$) { t.root = t._put(t.root, key) }&#10;&#10;func (t *treap) _delete(o *node, key $VAR0$) *node {&#10;&#9;if o == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;o.lr[d] = t._delete(o.lr[d], key)&#10;&#9;} else {&#10;&#9;&#9;if o.dupCnt &gt; 1 {&#10;&#9;&#9;&#9;o.dupCnt--&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;if o.lr[1] == nil {&#10;&#9;&#9;&#9;&#9;return o.lr[0]&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if o.lr[0] == nil {&#10;&#9;&#9;&#9;&#9;return o.lr[1]&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;d = 0&#10;&#9;&#9;&#9;if o.lr[0].priority &gt; o.lr[1].priority {&#10;&#9;&#9;&#9;&#9;d = 1&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;o = o.rotate(d)&#10;&#9;&#9;&#9;o.lr[d] = t._delete(o.lr[d], key)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;o.pushUp()&#10;&#9;return o&#10;}&#10;&#10;func (t *treap) delete(key $VAR0$) { t.root = t._delete(t.root, key) }&#10;&#10;func (t *treap) get(key $VAR0$) *node {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;&#9;o = o.lr[d]&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;return o&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func newTreap() *treap { return &amp;treap{rd: 1} }" description="treap multiset" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="set" value="type node struct {&#10;&#9;lr       [2]*node&#10;&#9;priority uint&#10;&#9;key      $VAR0$&#10;&#9;sz       int&#10;}&#10;&#10;func (o *node) size() int {&#10;&#9;if o != nil {&#10;&#9;&#9;return o.sz&#10;&#9;}&#10;&#9;return 0&#10;}&#10;&#10;func (o *node) pushUp() { o.sz = 1 + o.lr[0].size() + o.lr[1].size() }&#10;&#10;func (o *node) rotate(d int8) *node {&#10;&#9;x := o.lr[d^1]&#10;&#9;o.lr[d^1] = x.lr[d]&#10;&#9;x.lr[d] = o&#10;&#9;o.pushUp()&#10;&#9;x.pushUp()&#10;&#9;return x&#10;}&#10;&#10;type treap struct {&#10;&#9;rd   uint&#10;&#9;root *node&#10;}&#10;&#10;func (t *treap) fastRand() uint {&#10;&#9;t.rd ^= t.rd &lt;&lt; 13&#10;&#9;t.rd ^= t.rd &gt;&gt; 17&#10;&#9;t.rd ^= t.rd &lt;&lt; 5&#10;&#9;return t.rd&#10;}&#10;&#10;func (t *treap) less(a, b $VAR0$) int8 {&#10;&#9;switch {&#10;&#9;case a &lt; b:&#10;&#9;&#9;return 0&#10;&#9;case a &gt; b:&#10;&#9;&#9;return 1&#10;&#9;default:&#10;&#9;&#9;return -1&#10;&#9;}&#10;}&#10;&#10;func (t *treap) _put(o *node, key $VAR0$) *node {&#10;&#9;if o == nil {&#10;&#9;&#9;return &amp;node{priority: t.fastRand(), key: key, sz: 1}&#10;&#9;}&#10;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;o.lr[d] = t._put(o.lr[d], key)&#10;&#9;&#9;if o.lr[d].priority &gt; o.priority {&#10;&#9;&#9;&#9;o = o.rotate(d ^ 1)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;o.pushUp()&#10;&#9;return o&#10;}&#10;&#10;func (t *treap) put(key $VAR0$) { t.root = t._put(t.root, key) }&#10;&#10;func (t *treap) _delete(o *node, key $VAR0$) *node {&#10;&#9;if o == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;o.lr[d] = t._delete(o.lr[d], key)&#10;&#9;} else {&#10;&#9;&#9;if o.lr[1] == nil {&#10;&#9;&#9;&#9;return o.lr[0]&#10;&#9;&#9;}&#10;&#9;&#9;if o.lr[0] == nil {&#10;&#9;&#9;&#9;return o.lr[1]&#10;&#9;&#9;}&#10;&#9;&#9;d = 0&#10;&#9;&#9;if o.lr[0].priority &gt; o.lr[1].priority {&#10;&#9;&#9;&#9;d = 1&#10;&#9;&#9;}&#10;&#9;&#9;o = o.rotate(d)&#10;&#9;&#9;o.lr[d] = t._delete(o.lr[d], key)&#10;&#9;}&#10;&#9;o.pushUp()&#10;&#9;return o&#10;}&#10;&#10;func (t *treap) delete(key $VAR0$) { t.root = t._delete(t.root, key) }&#10;&#10;func (t *treap) get(key $VAR0$) *node {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;if d := t.less(key, o.key); d &gt;= 0 {&#10;&#9;&#9;&#9;o = o.lr[d]&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;return o&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func newTreap() *treap { return &amp;treap{rd: 1} }" description="treap set" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstprev" value="func (t *treap) prev(key $VAR0$) (prev *node) {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;if t.less(key, o.key) &lt;= 0 {&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;prev = o&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return // NOTE: check nil&#10;}" description="bst prev" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstlowerbound" value="func (t *treap) lowerBound(key $VAR0$) (lb *node) {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;switch d := t.less(key, o.key); {&#10;&#9;&#9;case d == 0:&#10;&#9;&#9;&#9;lb = o&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;case d &gt; 0:&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;return o&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return // NOTE: check nil&#10;}" description="bst lowerBound" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstnext" value="func (t *treap) next(key $VAR0$) (next *node) {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;if t.less(key, o.key) == 0 {&#10;&#9;&#9;&#9;next = o&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return // NOTE: check nil&#10;}" description="bst next" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstupperbound" value="func (t *treap) next(key $VAR0$) (next *node) {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;if t.less(key, o.key) == 0 {&#10;&#9;&#9;&#9;next = o&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return // NOTE: check nil&#10;}" description="bst upperBound" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstrank" value="func (t *treap) rank(key $VAR0$) (kth int) {&#10;&#9;for o := t.root; o != nil; {&#10;&#9;&#9;switch d := t.less(key, o.key); {&#10;&#9;&#9;case d == 0:&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;case d &gt; 0:&#10;&#9;&#9;&#9;kth += 1 + o.lr[0].size() // 1 &lt;-&gt; o.dupCnt&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;kth += o.lr[0].size()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return&#10;}" description="bst rank" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstmin" value="func (t *treap) min() (min *node) {&#10;&#9;for o := t.root; o != nil; o = o.lr[0] {&#10;&#9;&#9;min = o&#10;&#9;}&#10;&#9;return&#10;}" description="bst min" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstmax" value="func (t *treap) max() (max *node) {&#10;&#9;for o := t.root; o != nil; o = o.lr[1] {&#10;&#9;&#9;max = o&#10;&#9;}&#10;&#9;return&#10;}" description="bst max" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="bstkth" value="func (t *treap) kth(k int) (o *node) {&#10;&#9;//if k &lt; 0 || k &gt;= t.root.size() {&#10;&#9;//&#9;return&#10;&#9;//}&#10;&#9;for o = t.root; o != nil; {&#10;&#9;&#9;switch lsz := o.lr[0].size(); {&#10;&#9;&#9;case k &lt; lsz:&#10;&#9;&#9;&#9;o = o.lr[0]&#10;&#9;&#9;case k &gt; lsz:&#10;&#9;&#9;&#9;k -= 1 + lsz // 1 &lt;-&gt; o.dupCnt &amp; if k &lt; 0 { return }&#10;&#9;&#9;&#9;o = o.lr[1]&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return // NOTE: check nil&#10;}" description="bst kth" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="fastio" value="in := bufio.NewScanner(_r)&#10;in.Split(bufio.ScanWords)&#10;out := bufio.NewWriter(_w)&#10;defer out.Flush()&#10;read := func() (x int) {&#10;&#9;in.Scan()&#10;&#9;for _, b := range in.Bytes() {&#10;&#9;&#9;x = x*10 + int(b-'0')&#10;&#9;}&#10;&#9;return&#10;}" description="fast IO" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fpf" value="Fprintf(out, &quot;$FORMAT$&quot;, $VAR0$)" description="Fprintf(out, &quot;$FORMAT$&quot;, $VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="FORMAT" expression="" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="heap" value="type hp struct{ sort.IntSlice }&#10;&#10;func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }&#10;func (h *hp) Pop() (v interface{}) {&#10;&#9;n := len(h.IntSlice)&#10;&#9;h.IntSlice, v = h.IntSlice[:n-1], h.IntSlice[n-1]&#10;&#9;return&#10;}&#10;//func (h hp) Less(i, j int) bool { return h.IntSlice[i] &gt; h.IntSlice[j] } // 最大堆" description="h.IntSlice[0]" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="unique" value="unique := func(a []$TYPE$) (res []$TYPE$) {&#10;&#9;n := len(a)&#10;&#9;if n == 0 {&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;res = make([]$TYPE$, 1, n)&#10;&#9;res[0] = a[0]&#10;&#9;for i := 1; i &lt; n; i++ {&#10;&#9;&#9;if a[i] != a[i-1] {&#10;&#9;&#9;&#9;res = append(res, a[i])&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return&#10;}" description="unique := func(a []int) (res []int) {" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fio" value="in := bufio.NewScanner(_r)&#10;in.Split(bufio.ScanWords)&#10;out := bufio.NewWriter(_w)&#10;defer out.Flush()&#10;r := func() (x int) {&#10;&#9;in.Scan()&#10;&#9;for _, b := range in.Bytes() {&#10;&#9;&#9;x = x*10 + int(b-'0')&#10;&#9;}&#10;&#9;return&#10;}" description="fast IO" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="upperbound" value="upperBound := func(a []$TYPE$, x $TYPE$) int { return sort.Search(len(a), func(i int) bool { return a[i] &gt; x }) }" description="upperBound := func(a []int, x int) int { return sort.Search(len(a), func(i int) bool { return a[i] &gt; x }) }" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="blr" value="searchRange := func(l, r $TYPE$, f func($TYPE$) bool) $TYPE$ {&#10;&#9;i, j := l, r&#10;&#9;for i &lt; j {&#10;&#9;&#9;h := (i + j) &gt;&gt; 1&#10;&#9;&#9;if f(h) {&#10;&#9;&#9;&#9;j = h&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;i = h + 1&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return i&#10;}" description="binary search [l,r)" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="lcm" value="calcGCD := func(a, b $TYPE$) $TYPE$ {&#10;&#9;for a != 0 {&#10;&#9;&#9;a, b = b%a, a&#10;&#9;}&#10;&#9;return b&#10;}&#10;calcLCM := func(a, b $TYPE$) $TYPE$ { return a / calcGCD(a, b) * b }" description="calcLCM" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="reverse" value="reverse := func(a []$TYPE$) []$TYPE$ {&#10;&#9;n := len(a)&#10;&#9;r := make([]$TYPE$, n)&#10;&#9;for i, v := range a {&#10;&#9;&#9;r[n-1-i] = v&#10;&#9;}&#10;&#9;return r&#10;}" description="reverse slice" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;byte&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="equal" value="equals := func(a, b []$TYPE$) bool {&#10;&#9;// assert len(a) == len(b)&#10;&#9;for i, v := range a {&#10;&#9;&#9;if v != b[i] {&#10;&#9;&#9;&#9;return false&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return true&#10;}" description="check two slice equal" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="hp" value="type hp struct{ sort.IntSlice }&#10;&#10;func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }&#10;func (h *hp) Pop() (v interface{}) {&#10;&#9;n := len(h.IntSlice)&#10;&#9;h.IntSlice, v = h.IntSlice[:n-1], h.IntSlice[n-1]&#10;&#9;return&#10;}&#10;//func (h hp) Less(i, j int) bool { return h.IntSlice[i] &gt; h.IntSlice[j] } // 最大堆" description="type hp struct{ sort.IntSlice }" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="hp2" value="type hp []$TYPE$&#10;&#10;func (h hp) Len() int              { return len(h) }&#10;func (h hp) Less(i, j int) bool    { return h[i] &lt; h[j] } // &gt; 为最大堆&#10;func (h hp) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }&#10;func (h *hp) Push(v interface{})   { *h = append(*h, v.($TYPE$)) }&#10;func (h *hp) Pop() (v interface{}) { n := len(*h); *h, v = (*h)[:n-1], (*h)[n-1]; return }" description="type hp []$TYPE$" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int64&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="ffa" value="$VAR0$ := make([][]$TYPE$, $VAR1$)&#10;for i := range $VAR0$ {&#10; $VAR0$[i] = make([]$TYPE$, $VAR2$)&#10; for j := range $VAR0$[i] {&#10;  Fscan(in, &amp;$VAR0$[i][j])&#10; }&#10;}" description="for for array read (read mat)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;mat&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="" defaultValue="&quot;m&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fg" value="g := make([][]int, $VAR0$)&#10;for i := 0; i &lt; $VAR1$; i++ {&#10;&#9;var v, w int&#10;&#9;Fscan(in, &amp;v, &amp;w)&#10;&#9;v--&#10;&#9;w--&#10;&#9;g[v] = append(g[v], w)&#10;&#9;g[w] = append(g[w], v)&#10;}" description="for read graph" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="" defaultValue="&quot;m&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs2" value="Fscan(in, &amp;$VAR0$, &amp;$VAR1$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs3" value="Fscan(in, &amp;$VAR0$, &amp;$VAR1$, &amp;$VAR2$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="mib" value="map[int]bool{}" description="map[int]bool{}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO" value="true" />
      <option name="GO_BLOCK" value="false" />
      <option name="GO_FILE" value="false" />
      <option name="GO_STATEMENT" value="false" />
      <option name="GO_TAG_LITERAL" value="false" />
      <option name="GO_TYPE" value="false" />
    </context>
  </template>
  <template name="make2" value="$VARNAME$ := make([][]$TYPE$, $VAR0$)&#10;for i := range $VARNAME$ {&#10;&#9;$VARNAME$[i] = make([]$TYPE$, $VAR1$)&#10;&#9;for j := range $VARNAME$[i] {&#10;&#9;&#9;$VARNAME$[i][j] = $INIT$&#10;&#9;}&#10;}" description="make 2D slice" toReformat="true" toShortenFQNames="true">
    <variable name="VARNAME" expression="" defaultValue="&quot;mat&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="INIT" expression="" defaultValue="&quot;-1&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs4" value="Fscan(in, &amp;$VAR0$, &amp;$VAR1$, &amp;$VAR2$, &amp;$VAR3$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR3" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="read" value="read := func() (x int) {&#10;&#9;in.Scan()&#10;&#9;data := in.Bytes()&#10;&#9;if data[0] == '-' {&#10;&#9;&#9;for _, b := range data[1:] {&#10;&#9;&#9;&#9;x = x*10 + int(b-'0')&#10;&#9;&#9;}&#10;&#9;&#9;return -x&#10;&#9;}&#10;&#9;for _, b := range data {&#10;&#9;&#9;x = x*10 + int(b-'0')&#10;&#9;}&#10;&#9;return&#10;}" description="fast read include neg" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="df" value="defer func() {$END$}()" description="defer func(){}" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs5" value="Fscan(in, &amp;$VAR0$, &amp;$VAR1$, &amp;$VAR2$, &amp;$VAR3$, &amp;$VAR4$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR3" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR4" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fs6" value="Fscan(in, &amp;$VAR0$, &amp;$VAR1$, &amp;$VAR2$, &amp;$VAR3$, &amp;$VAR4$, &amp;$VAR5$)" description="Fscan(in, &amp;$VAR0$)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR2" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR3" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR4" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR5" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="tpless" value="type pair struct{ x, y $TYPE$ }&#10;less := func(a, b pair) bool { return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y }" description="type pair &amp; less := func(a, b pair) bool" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="less2" value="$AX$ &lt; $BX$ || $AX$ == $BX$ &amp;&amp; $AY$ &lt; $BY$" description="type pair &amp; less := func(a, b pair) bool" toReformat="true" toShortenFQNames="true">
    <variable name="AX" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="BX" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="AY" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="BY" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="dp2" value="dp := make([][]$DP_TYPE$, $ROW_SIZE$)&#10;for i := range dp {&#10;&#9;dp[i] = make([]int, $COL_SIZE$)&#10;&#9;for j := range dp[i] {&#10;&#9;&#9;dp[i][j] = -1&#10;&#9;}&#10;}&#10;var f func(int, int) int&#10;f = func($NAME0$, $NAME1$ int) (_ans int) {&#10;&#9;dv := &amp;dp[$NAME0$][$NAME1$]&#10;&#9;if *dv &gt;= 0 {&#10;&#9;&#9;return *dv&#10;&#9;}&#10;&#9;defer func() { *dv = _ans }()&#10;&#9;$END$&#10;&#9;return&#10;}" description="dp := make2 &amp; var func" toReformat="true" toShortenFQNames="true">
    <variable name="DP_TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="ROW_SIZE" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="COL_SIZE" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="NAME0" expression="" defaultValue="&quot;l&quot;" alwaysStopAt="true" />
    <variable name="NAME1" expression="" defaultValue="&quot;r&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="dp" value="dp := make([]$DP_TYPE$, $ROW_SIZE$)&#10;for i := range dp {&#10;&#9;dp[i] = -1&#10;}&#10;var f func(int) int&#10;f = func($NAME0$ int) (_ans int) {&#10;&#9;dv := &amp;dp[$NAME0$]&#10;&#9;if *dv &gt;= 0 {&#10;&#9;&#9;return *dv&#10;&#9;}&#10;&#9;defer func() { *dv = _ans }()&#10;&#9;$END$&#10;&#9;return&#10;}" description="dp := make &amp; var func" toReformat="true" toShortenFQNames="true">
    <variable name="DP_TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="ROW_SIZE" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="NAME0" expression="" defaultValue="&quot;p&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="combinations" value="combinations := func(n, r int, do func(indexes []int)) {&#10;&#9;indexes := make([]int, r)&#10;&#9;for i := range indexes {&#10;&#9;&#9;indexes[i] = i&#10;&#9;}&#10;&#9;do(indexes)&#10;&#9;for {&#10;&#9;&#9;i := r - 1&#10;&#9;&#9;for ; i &gt;= 0; i-- {&#10;&#9;&#9;&#9;if indexes[i] != i+n-r {&#10;&#9;&#9;&#9;&#9;break&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;if i == -1 {&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;indexes[i]++&#10;&#9;&#9;for j := i + 1; j &lt; r; j++ {&#10;&#9;&#9;&#9;indexes[j] = indexes[j-1] + 1&#10;&#9;&#9;}&#10;&#9;&#9;do(indexes)&#10;&#9;}&#10;}" description="combinations := func(n, r int, do func(indexes []int)) {" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="permutations" value="permutations := func(n, r int, do func(indexes []int)) {&#10;&#9;indexes := make([]int, n)&#10;&#9;for i := range indexes {&#10;&#9;&#9;indexes[i] = i&#10;&#9;}&#10;&#9;do(indexes[:r])&#10;&#9;cycles := make([]int, r)&#10;&#9;for i := range cycles {&#10;&#9;&#9;cycles[i] = n - i&#10;&#9;}&#10;&#9;for {&#10;&#9;&#9;i := r - 1&#10;&#9;&#9;for ; i &gt;= 0; i-- {&#10;&#9;&#9;&#9;cycles[i]--&#10;&#9;&#9;&#9;if cycles[i] == 0 {&#10;&#9;&#9;&#9;&#9;tmp := indexes[i]&#10;&#9;&#9;&#9;&#9;copy(indexes[i:], indexes[i+1:])&#10;&#9;&#9;&#9;&#9;indexes[n-1] = tmp&#10;&#9;&#9;&#9;&#9;cycles[i] = n - i&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;j := cycles[i]&#10;&#9;&#9;&#9;&#9;indexes[i], indexes[n-j] = indexes[n-j], indexes[i]&#10;&#9;&#9;&#9;&#9;do(indexes[:r])&#10;&#9;&#9;&#9;&#9;break&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;if i == -1 {&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;}" description="permutations := func(n, r int, do func(indexes []int)) {" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="trie" value="type trieNode struct {&#10;&#9;son    [$SON_SIZE$]*trieNode&#10;&#9;dupCnt int&#10;&#9;val    int&#10;}&#10;&#10;type trie struct{ root *trieNode }&#10;&#10;func (*trie) ord(c byte) byte { return c - $BASE_CHAR$ }&#10;&#10;func (t *trie) put(s []byte, val int) {&#10;&#9;o := t.root&#10;&#9;for _, c := range s {&#10;&#9;&#9;c = t.ord(c)&#10;&#9;&#9;if o.son[c] == nil {&#10;&#9;&#9;&#9;o.son[c] = &amp;trieNode{}&#10;&#9;&#9;}&#10;&#9;&#9;o = o.son[c]&#10;&#9;&#9;//o.dupCnt++ // 经过节点 o 的字符串个数&#10;&#9;&#9;//o.val = val // 更新 s 的所有前缀的值&#10;&#9;}&#10;&#9;o.dupCnt++&#10;&#9;o.val = val&#10;}&#10;&#10;func (t *trie) get(s []byte) *trieNode {&#10;&#9;o := t.root&#10;&#9;for _, c := range s {&#10;&#9;&#9;o = o.son[t.ord(c)]&#10;&#9;&#9;if o == nil {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if o.dupCnt == 0 {&#10;&#9;&#9;return nil&#10;&#9;} // s 只是某个字符串的前缀&#10;&#9;return o&#10;}&#10;&#10;func newTrie() *trie {&#10;&#9;return &amp;trie{&amp;trieNode{}}&#10;}" description="trie" toReformat="true" toShortenFQNames="true">
    <variable name="SON_SIZE" expression="" defaultValue="&quot;26&quot;" alwaysStopAt="true" />
    <variable name="BASE_CHAR" expression="" defaultValue="&quot;'a'&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="dir4for" value="for _, d := range dir4 {&#10;&#9;if xx, yy := x+d[0], y+d[1]; xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; $VAR0$[xx][yy] {&#10;&#9;&#9;$END$&#10;&#9;}&#10;}" description="for _, d := range dir4 {" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;vis&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="makei" value="make([]int, $VAR0$)" description="make([]int, ...)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="mi" value="make([]int, $VAR0$)" description="make([]int, ...)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="mb" value="make([]bool, $VAR0$)" description="make([]bool, ...)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="m2" value="$VARNAME$ := make([][]$TYPE$, $VAR0$)&#10;for i := range $VARNAME$ {&#10;&#9;$VARNAME$[i] = make([]$TYPE$, $VAR1$)&#10;&#9;for j := range $VARNAME$[i] {&#10;&#9;&#9;$VARNAME$[i][j] = $INIT$&#10;&#9;}&#10;}" description="make 2D slice" toReformat="true" toShortenFQNames="true">
    <variable name="VARNAME" expression="" defaultValue="&quot;mat&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="VAR1" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <variable name="INIT" expression="" defaultValue="&quot;-1&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="makeb" value="make([]bool, $VAR0$)" description="make([]bool, ...)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_EXPRESSION" value="true" />
    </context>
  </template>
  <template name="lesspair" value="less := func(a, b pair) bool { return a.$X$ &lt; b.$X$ || a.$X$ == b.$X$ &amp;&amp; a.$Y$ &lt; b.$Y$ }" description="less := func(a, b pair) bool { return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y }" toReformat="true" toShortenFQNames="true">
    <variable name="X" expression="complete()" defaultValue="&quot;x&quot;" alwaysStopAt="true" />
    <variable name="Y" expression="complete()" defaultValue="&quot;y&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="lessslice" value="less := func(a, b []$TYPE$) bool {&#10;&#9;for i, ai := range a {&#10;&#9;&#9;if ai != b[i] {&#10;&#9;&#9;&#9;return ai &lt; b[i]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return false&#10;}" description="less := func(a, b []$TYPE$) bool {" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="deque" value="type deque struct{ l, r []$TYPE$ }&#10;&#10;func (q deque) empty() bool  { return len(q.l) == 0 &amp;&amp; len(q.r) == 0 }&#10;func (q *deque) pushL(v $TYPE$) { q.l = append(q.l, v) }&#10;func (q *deque) pushR(v $TYPE$) { q.r = append(q.r, v) }&#10;func (q *deque) popL() (v $TYPE$) {&#10;&#9;if len(q.l) &gt; 0 {&#10;&#9;&#9;q.l, v = q.l[:len(q.l)-1], q.l[len(q.l)-1]&#10;&#9;} else {&#10;&#9;&#9;v, q.r = q.r[0], q.r[1:]&#10;&#9;}&#10;&#9;return&#10;}&#10;func (q *deque) popR() (v $TYPE$) {&#10;&#9;if len(q.r) &gt; 0 {&#10;&#9;&#9;q.r, v = q.r[:len(q.r)-1], q.r[len(q.r)-1]&#10;&#9;} else {&#10;&#9;&#9;v, q.l = q.l[0], q.l[1:]&#10;&#9;}&#10;&#9;return&#10;}" description="deque" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_FILE" value="true" />
    </context>
  </template>
  <template name="fenwicktree" value="tree := make([]$TYPE$, $MX$+1)&#10;add := func(i int, val $TYPE$) {&#10;&#9;for ; i &lt;= $MX$; i += i &amp; -i {&#10;&#9;&#9;tree[i] += val&#10;&#9;}&#10;}&#10;sum := func(i int) (res $TYPE$) {&#10;&#9;for ; i &gt; 0; i &amp;= i - 1 {&#10;&#9;&#9;res += tree[i]&#10;&#9;}&#10;&#9;return&#10;}&#10;query := func(l, r int) $TYPE$ { return sum(r) - sum(l-1) } // [l,r]" description="Fenwick Tree" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="MX" expression="" defaultValue="&quot;n&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="st" value="var st [][$MX$]$TYPE$&#10;stInit := func(a []$TYPE$) {&#10;&#9;n := len(a)&#10;&#9;st = make([][$MX$]$TYPE$, n)&#10;&#9;for i, v := range a {&#10;&#9;&#9;st[i][0] = v&#10;&#9;}&#10;&#9;for j := uint(1); 1&lt;&lt;j &lt;= n; j++ {&#10;&#9;&#9;for i := 0; i+1&lt;&lt;j-1 &lt; n; i++ {&#10;&#9;&#9;&#9;st[i][j] = $FUNC$(st[i][j-1], st[i+1&lt;&lt;(j-1)][j-1])&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;// [l,r) 注意 l r 是从 0 开始算的&#10;stQuery := func(l, r int) $TYPE$ { k := bits.Len(uint(r-l)) - 1; return $FUNC$(st[l][k], st[r-1&lt;&lt;uint(k)][k]) }" description="Sparse Table" toReformat="true" toShortenFQNames="true">
    <variable name="MX" expression="" defaultValue="&quot;17&quot;" alwaysStopAt="true" />
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <variable name="FUNC" expression="complete()" defaultValue="&quot;min&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="contains" value="contains := func(a []$TYPE$, x $TYPE$) bool {&#10;&#9;for _, v := range a {&#10;&#9;&#9;if v == x {&#10;&#9;&#9;&#9;return true&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return false&#10;}" description="contains := func(a []$TYPE$, x $TYPE$) bool {" toReformat="true" toShortenFQNames="true">
    <variable name="TYPE" expression="" defaultValue="&quot;int&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
  <template name="fpt" value="Fprint(out, $VAR0$, &quot; &quot;)" description="Fprint(out, $VAR0$, &quot; &quot;)" toReformat="true" toShortenFQNames="true">
    <variable name="VAR0" expression="complete()" defaultValue="&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="GO_STATEMENT" value="true" />
    </context>
  </template>
</templateSet>