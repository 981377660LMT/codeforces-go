首先 $[A,B]$ 范围内的每个数都可以取到，先把 $B-A+1$ 加到答案中。

由于 OR 操作不会让数字变小，接下来只需要考虑：还可以 OR 出哪些大于 $B$ 的数字？

举例说明。

```
B=1011001100
A=1010110001
```

由于 $A$ 和 $B$ 的最长公共前缀 `101` 肯定是没法改变的，干脆去掉最长公共前缀，只考虑剩余的部分。

```
B=1001100
A=0110001
```

此时 $B$ 的最高位一定是 $1$，$A$ 的最高位一定是 $0$。（如果 $A=B$，直接输出 $1$。）

### 第一类构造方案

取 $[A,B]$ 内的两个数 $x$ 和 $y$：

```
x=1000000 // 只保留最高位的 1
y=0111111 // x-1 
```

这两个数 OR 一下，可以得到最大的数 `M=1111111`。

如果继续减少 $y$，只能减少到 $A$，这意味着我们可以得到 $[x|A,M]$ 内的所有数，这一共有 $M-(x|A)+1$ 个数，加到答案中。

### 第二类构造方案

取 $[A,B]$ 内的两个数 $p$ 和 $q$：

```
p=1001000 // 保留最高位和次高位的 1
q=1000111 // p-1
```

这两个数 OR 一下，得到 `M2=1001111`。

继续减少 $q$ 可以一直减少到 $1000000$，这意味着我们可以得到 $[B+1,M_2]$ 内的所有数，这一共有 $M_2-B$ 个数，加到答案中。

### 特殊情况

如果 $A$ 最高位的 $1$ 小于等于 $B$ 次高位的 $1$，例如

```
B=1001100
A=0000100
```

这会导致 $[B+1,M_2]$ 和 $[x|A,M]$ 有交集，即 $M_2\ge x|A$。

这两个区间并起来是 $[B+1,M]$，我们可以直接把 $M-B$ 加到答案中。

代码实现时，由于这些大于 $B$ 的数的最高位都是 $1$，可以在最长公共前缀的基础上再去掉一位。

```go
package main
import(."fmt";"math/bits")

func main() {
	var low, high uint
	Scan(&low, &high)
	if low == high {
		Print(1)
		return
	}
	ans := high - low + 1
	mask := uint(1)<<(bits.Len(high^low)-1) - 1
	high &= mask
	low &= mask
	nh := bits.Len(high)
	if bits.Len(low) <= nh {
		ans += mask - high
	} else {
		ans += mask - low + uint(1)<<nh - high
	}
	Print(ans)
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(1)$。
- 空间复杂度：$\mathcal{O}(1)$。
